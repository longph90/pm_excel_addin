{"version":3,"file":"taskpane.js","mappings":"wDAuMO,SAASA,EACdC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,OAAOC,MAAMC,KAAI,SAACC,GAChB,IACMC,EADcD,EAAQE,SAASC,WAAWC,QAAQd,GACxBe,OAAOD,QAAQb,GAEzCe,EADcN,EAAQE,SAASC,WAAWC,QAAQV,GACxBW,OAAOD,QAAQT,GAGzCY,EAAcN,EAAYO,mBAC1BC,EAAcH,EAAYE,mBAEhCD,EAAYG,KAAK,UACjBD,EAAYC,KAAK,UAGjB,IAAMC,EAAoBV,EAAYW,oBAChCC,EAAoBP,EAAYM,oBAItC,OAHAD,EAAkBD,KAAK,UACvBG,EAAkBH,KAAK,UAEhBV,EACJc,OACAC,MAAK,WACJ,IAAMC,EAAaT,EAAYU,OACzBC,EAAaT,EAAYQ,OACzBE,EAAa,IAAIC,IAAIF,EAAWG,KAAI,SAACC,GAAG,OAAKA,EAAI,EAAE,KAGnDC,EAAgBZ,EAAkBM,OAAO,GACzCO,EAAgBX,EAAkBI,OAAO,GACzCQ,EAAoBF,EAAcG,QAAQlC,GAC1CmC,EAAuBlC,EAAqB4B,KAAI,SAACO,GAAG,OAAKL,EAAcG,QAAQE,EAAI,IAEnFC,GADoBL,EAAcE,QAAQ9B,GACnBC,EAAqBwB,KAAI,SAACO,GAAG,OAAKJ,EAAcE,QAAQE,EAAI,KAEnFE,EAAU,GA4BhB,GAzBAd,EAAWe,SAAQ,SAACT,GAClB,IAAMU,EAAWV,EAAIG,GAErB,IAAKN,EAAWc,IAAID,GAAW,CAC7B,IAAIE,EAAS,IAAIC,MAAMX,EAAcY,QAAQC,KAAK,IAClDV,EAAqBI,SAAQ,SAACO,EAAaC,GACzC,IAAMC,EAAcX,EAAqBU,GACzCL,EAAOM,GAAelB,EAAIgB,EAC5B,IACAR,EAAQW,KAAKP,EACf,CAYF,IAGIJ,EAAQM,OAAS,EAEnB,OADA9B,EAAYoC,KAAKC,IAAI,KAAMb,GACpB9B,EAAQc,OAAOC,MAAK,WACzB6B,QAAQC,IAAI,wCAAyCf,EAAQM,OAC/D,IAEAQ,QAAQC,IAAI,yBAEhB,IACCC,OAAM,SAACC,GACNH,QAAQG,MAAMA,EAChB,GACJ,GACF,C,mCC3RIC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,CCrBAJ,EAAoBO,EAAI,SAASH,EAASI,GACzC,IAAI,IAAIC,KAAOD,EACXR,EAAoBU,EAAEF,EAAYC,KAAST,EAAoBU,EAAEN,EAASK,IAC5EE,OAAOC,eAAeR,EAASK,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAG3E,ECPAT,EAAoBU,EAAI,SAASK,EAAKC,GAAQ,OAAOL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,EAAO,E,WCQtGI,OAAOC,SAAQ,SAACC,GACd,GAAIA,EAAKC,OAASH,OAAOI,SAAS3E,MAAO,CACvC,IAGM4E,EAAU,CAAC,KAAM,SAAU,QAAS,MAAO,MAAO,OAIlDC,EAAU,CAAC,SAAU,WAAY,WAAY,cAAe,YAAa,iBAE/EC,SAASC,eAAe,eAAeC,QAAU,YAC/CzF,EAAAA,EAAAA,IAVc,eACA,kBACD,KAQqBqF,EANpB,MACA,SACD,SAIwDC,EACvE,CACF,CACF,G","sources":["webpack://office-addin-taskpane-js/./src/commons/common.js","webpack://office-addin-taskpane-js/webpack/bootstrap","webpack://office-addin-taskpane-js/webpack/runtime/define property getters","webpack://office-addin-taskpane-js/webpack/runtime/hasOwnProperty shorthand","webpack://office-addin-taskpane-js/./src/taskpane/taskpane.js"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global console, document, Excel, Office */\n/* global bootstrap */\n\n/**\n * Converts a JavaScript Date string to an Excel date number.\n * @param {string} dateString - The date string in 'YYYY-MM-DD' format.\n * @returns {number} The Excel date number.\n */\nexport function jsDateToExcelDate(dateString) {\n  // Convert the date string to a JavaScript Date object\n  const date = new Date(dateString);\n  // Convert JavaScript Date to Excel date number\n  let excelDate = 25569.0 + (date.getTime() - date.getTimezoneOffset() * 60 * 1000) / (1000 * 60 * 60 * 24);\n  return excelDate;\n}\n\n/**\n * Converts an Excel date number to a JavaScript Date object.\n * @param {number} excelDate - The Excel date number.\n * @returns {string} The date in 'YYYY-MM-DD' format, or an empty string if input is invalid.\n */\nexport function excelDateToJSDate(excelDate) {\n  // Check if the input is valid\n  if (!excelDate || isNaN(excelDate)) {\n    return \"\";\n  }\n  // Convert Excel date to JavaScript Date\n  const utcDate = new Date((excelDate - 25569) * 86400 * 1000);\n  // Return the date in 'YYYY-MM-DD' format\n  return utcDate.toISOString().split(\"T\")[0];\n}\n\n/**\n * Displays a notification message to the user.\n * @param {string} message - The message to display.\n * @param {string} type - The type of notification (e.g., 'success', 'error', 'warning').\n */\nexport function showNotification(message, type) {\n  // Get the notification element\n  const notificationEl = document.getElementById(\"notification\");\n\n  // Set the message content\n  notificationEl.textContent = message;\n\n  // Set the CSS classes for styling and positioning\n  notificationEl.className = `alert alert-${type}`;\n\n  // Make the notification visible\n  notificationEl.style.display = \"block\";\n\n  // Hide the notification after 5 seconds\n  setTimeout(() => {\n    notificationEl.style.display = \"none\";\n  }, 5000);\n}\n\nexport async function getDataTable(sheetName, tableName) {\n  try {\n    return await Excel.run(async (context) => {\n      // Get the specified sheet\n      const sheet = context.workbook.worksheets.getItem(sheetName);\n      // Get the specified table\n      const table = sheet.tables.getItem(tableName);\n      // Load the header row\n      const range = table.getRange();\n      range.load(\"values\");\n\n      await context.sync();\n      return range.values; // Trả về dữ liệu\n    });\n  } catch (error) {\n    showNotification(\"Error when reading data from \" + sheetName + \": \" + error.message, \"danger\");\n    throw error; // Ném lỗi để xử lý bên ngoài\n  }\n}\n\nexport async function getDataHeader(sheetName, tableName) {\n  try {\n    const data = await getDataTable(sheetName, tableName);\n    return data[0];\n  } catch (error) {\n    showNotification(\"Error when reading data from\" + sheetName + \": \" + error.message, \"danger\");\n  }\n}\n\nexport async function getIndexByColumnName(sheetName, tableName, columnName) {\n  try {\n    const data = await getDataTable(sheetName, tableName);\n    return data[0].indexOf(columnName);\n  } catch (error) {\n    return -1;\n  }\n}\n\nexport function getIndexRowbyTaskId(data, taskId) {\n  try {\n    const taskIndex = data.findIndex((row) => row[0] === taskId); // Tìm index của task\n    return taskIndex;\n  } catch (error) {\n    return -1;\n  }\n}\nexport function updateDataTable(sheetName, tableName, rowIndex, updateDict) {\n  return new Promise((resolve, reject) => {\n    Excel.run((context) => {\n      // Lấy sheet được chỉ định\n      let sheet = context.workbook.worksheets.getItem(sheetName);\n      // Lấy table được chỉ định\n      let table = sheet.tables.getItem(tableName);\n      // Lấy range của table\n      let range = table.getRange();\n      range.load(\"values\");\n\n      return context.sync().then(() => {\n        // Lấy header row\n        let headerRow = range.values[0];\n        // Tạo map từ tên cột đến index\n        let columnIndexMap = {};\n        headerRow.forEach((columnName, index) => {\n          columnIndexMap[columnName] = index;\n        });\n\n        // Cập nhật các giá trị tại vị trí chỉ định\n        for (let columnName in updateDict) {\n          if (Object.prototype.hasOwnProperty.call(updateDict, columnName)) {\n            let columnIndex = columnIndexMap[columnName];\n            if (columnIndex !== undefined) {\n              range.values[rowIndex][columnIndex] = updateDict[columnName];\n            } else {\n              reject(`Column name \"${columnName}\" not found`);\n              return;\n            }\n          }\n        }\n\n        // Chỉ cập nhật đúng range ứng với rowIndex\n        let rowRange = table.getDataBodyRange().getRow(rowIndex);\n        rowRange.values = [range.values[rowIndex]];\n\n        return context.sync().then(() => {\n          resolve(\"Data updated successfully\");\n        });\n      });\n    }).catch((error) => {\n      showNotification(\"Error when updating data in \" + sheetName + \": \" + error.message, \"danger\");\n      reject(error);\n    });\n  });\n}\n\nexport function insertDataTable(sheetName, tableName, updateDict) {\n  return new Promise((resolve, reject) => {\n    Excel.run((context) => {\n      // Lấy sheet được chỉ định\n      let sheet = context.workbook.worksheets.getItem(sheetName);\n      // Lấy table được chỉ định\n      let table = sheet.tables.getItem(tableName);\n      // Lấy range của table\n      let range = table.getRange();\n      range.load(\"values\");\n\n      return context.sync().then(() => {\n        // Lấy header row\n        let headerRow = range.values[0];\n        // Tạo một mảng mới cho hàng cần thêm\n        let newRow = new Array(headerRow.length).fill(\"\");\n\n        // Cập nhật các giá trị từ updateDict\n        for (let columnName in updateDict) {\n          if (Object.prototype.hasOwnProperty.call(updateDict, columnName)) {\n            let columnIndex = headerRow.indexOf(columnName);\n            if (columnIndex !== -1) {\n              newRow[columnIndex] = updateDict[columnName];\n            } else {\n              reject(`Column name \"${columnName}\" not found`);\n              return;\n            }\n          }\n        }\n\n        // Thêm hàng mới vào cuối table\n        table.rows.add(null, [newRow]);\n\n        return context.sync().then(() => {\n          resolve(\"Data inserted successfully\");\n        });\n      });\n    }).catch((error) => {\n      showNotification(\"Error when inserting data in \" + sheetName + \": \" + error.message, \"danger\");\n      reject(error);\n    });\n  });\n}\n\nexport function mapData(\n  SheetNameSource,\n  TableNameSource,\n  KeyColumnNameSource,\n  ListColumnNameSource,\n  SheetNameTarget,\n  TableNameTarget,\n  KeyColumnNameTarget,\n  ListColumnNameTarget\n) {\n  return Excel.run((context) => {\n    const sourceSheet = context.workbook.worksheets.getItem(SheetNameSource);\n    const sourceTable = sourceSheet.tables.getItem(TableNameSource);\n    const targetSheet = context.workbook.worksheets.getItem(SheetNameTarget);\n    const targetTable = targetSheet.tables.getItem(TableNameTarget);\n\n    // Load the data from source and target tables\n    const sourceRange = sourceTable.getDataBodyRange();\n    const targetRange = targetTable.getDataBodyRange();\n\n    sourceRange.load(\"values\");\n    targetRange.load(\"values\");\n\n    // Load header rows\n    const sourceHeaderRange = sourceTable.getHeaderRowRange();\n    const targetHeaderRange = targetTable.getHeaderRowRange();\n    sourceHeaderRange.load(\"values\");\n    targetHeaderRange.load(\"values\");\n\n    return context\n      .sync()\n      .then(() => {\n        const sourceData = sourceRange.values;\n        const targetData = targetRange.values;\n        const targetKeys = new Set(targetData.map((row) => row[0])); // Assuming KeyColumnNameTarget is the first column\n\n        // Get indexes for columns\n        const headersSource = sourceHeaderRange.values[0];\n        const headersTarget = targetHeaderRange.values[0];\n        const keyColIndexSource = headersSource.indexOf(KeyColumnNameSource);\n        const listColIndexesSource = ListColumnNameSource.map((col) => headersSource.indexOf(col));\n        const keyColIndexTarget = headersTarget.indexOf(KeyColumnNameTarget);\n        const listColIndexesTarget = ListColumnNameTarget.map((col) => headersTarget.indexOf(col));\n\n        const newRows = [];\n\n        // Loop through source data to find new entries\n        sourceData.forEach((row) => {\n          const keyValue = row[keyColIndexSource];\n\n          if (!targetKeys.has(keyValue)) {\n            let newRow = new Array(headersTarget.length).fill(\"\");\n            listColIndexesSource.forEach((sourceIndex, index) => {\n              const targetIndex = listColIndexesTarget[index];\n              newRow[targetIndex] = row[sourceIndex];\n            });\n            newRows.push(newRow);\n          }\n          // else {\n          //   const taskIndex = targetData.findIndex((row) => row[keyColIndexTarget] === keyValue);\n          //   if (taskIndex !== -1) {\n          //     const updatedRow = [...targetData[taskIndex]];\n          //     listColIndexesSource.forEach((sourceIndex, index) => {\n          //       const targetIndex = listColIndexesTarget[index];\n          //       updatedRow[targetIndex] = row[sourceIndex];\n          //     });\n          //     targetRange.getRow(taskIndex).values = [updatedRow];\n          //   }\n          // }\n        });\n\n        // If there are new rows to insert, add them to the target table\n        if (newRows.length > 0) {\n          targetTable.rows.add(null, newRows);\n          return context.sync().then(() => {\n            console.log(\"Mapping completed. New rows inserted:\", newRows.length);\n          });\n        } else {\n          console.log(\"No new rows to insert.\");\n        }\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n  });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\nimport { mapData } from \"../commons/common\";\n\n/* global console, document, Excel, Office */\nOffice.onReady((info) => {\n  if (info.host === Office.HostType.Excel) {\n    const shNameS = \"ExternalData\";\n    const tbNameS = \"TblExternalData\";\n    const kNameS = \"キー\";\n    const lcNameS = [\"キー\", \"カテゴリー名\", \"親課題キー\", \"開始日\", \"期限日\", \"期限日\"];\n    const shNameT = \"WBS\";\n    const tbNameT = \"TblWbs\";\n    const kNameT = \"TaskID\";\n    const lcNameT = [\"TaskID\", \"TaskName\", \"ParentID\", \"P.StartDate\", \"P.EndDate\", \"P.ReleaseDate\"];\n\n    document.getElementById(\"btnSyncData\").onclick = function () {\n      mapData(shNameS, tbNameS, kNameS, lcNameS, shNameT, tbNameT, kNameT, lcNameT);\n    };\n  }\n});\n\nfunction mappingTask() {\n  return Excel.run(function (context) {\n    const externalTable = context.workbook.tables.getItem(\"TblExternalData\");\n    const wbsTable = context.workbook.tables.getItem(\"TblWbs\");\n\n    // Lấy dữ liệu từ TblExternalData\n    const externalRange = externalTable.getDataBodyRange();\n    const wbsRange = wbsTable.getDataBodyRange();\n\n    externalRange.load(\"values\");\n    wbsRange.load(\"values\");\n\n    // Tải hàng tiêu đề\n    const headerRowRange = externalTable.getHeaderRowRange();\n    headerRowRange.load(\"values\");\n\n    return context.sync().then(function () {\n      const externalData = externalRange.values;\n      const wbsData = wbsRange.values;\n      const wbsTaskIDs = new Set(wbsData.map((row) => row[0])); // Giả sử TaskID ở cột đầu tiên\n\n      // Lấy tiêu đề cột từ TblExternalData\n      const headersExternal = headerRowRange.values[0];\n      const keyIndex = headersExternal.indexOf(\"キー\");\n      const parentIdIndex = headersExternal.indexOf(\"親課題キー\");\n      const startDateIndex = headersExternal.indexOf(\"開始日\");\n      const endDateIndex = headersExternal.indexOf(\"期限日\");\n      const category = headersExternal.indexOf(\"カテゴリー名\");\n\n      // Duyệt qua dữ liệu từ TblExternalData\n      for (const row of externalData) {\n        const key = row[keyIndex]; // Lấy giá trị từ cột キー\n        if (!wbsTaskIDs.has(key)) {\n          const taskID = key;\n          const taskName = row[category];\n          const type = \"\";\n          const pic = \"\";\n          const reviewer = \"\";\n          const pStartDate = row[startDateIndex];\n          const pEndDate = row[endDateIndex];\n          const pReleaseDate = \"\";\n          const pEffort = \"\";\n          const aStartDate = \"\";\n          const aEndDate = \"\";\n          const aEffort = \"\";\n          const percentACompleted = \"\";\n          const aReleaseDate = \"\";\n          const parentID = row[parentIdIndex];\n          const linkBackLog = \"\";\n          const linkJira = \"\";\n          const linkEvidence = \"\";\n          const cause = \"\";\n          const note = \"\";\n\n          // Thêm hàng mới vào bảng\n          wbsTable.rows.add(null, [\n            [\n              taskID,\n              taskName,\n              type,\n              pic,\n              reviewer,\n              pStartDate,\n              pEndDate,\n              pReleaseDate,\n              pEffort,\n              aStartDate,\n              aEndDate,\n              aEffort,\n              percentACompleted,\n              aReleaseDate,\n              parentID,\n              linkBackLog,\n              linkJira,\n              linkEvidence,\n              cause,\n              note,\n            ],\n          ]);\n        } else {\n          const taskIndex = wbsData.findIndex((row) => row[0] === key); // Tìm index của task\n          if (taskIndex !== -1) {\n            // Tạo một mảng mới với các giá trị cập nhật\n            const updatedRow = [...wbsData[taskIndex]];\n            updatedRow[1] = row[category];\n\n            // Cập nhật toàn bộ hàng\n            wbsRange.getRow(taskIndex).values = [updatedRow];\n          }\n        }\n      }\n\n      return context.sync().then(() => {\n        showNotification(\"Task synced successfully!\", \"success\");\n      });\n    });\n  }).catch(function (error) {\n    console.log(error);\n    showNotification(`Error: ${error.message}`, \"danger\");\n  });\n}\n\nfunction showNotification(message, type) {\n  const notificationEl = document.getElementById(\"notification\");\n  notificationEl.textContent = message;\n  notificationEl.className = `alert alert-${type} position-fixed bottom-0 start-50 translate-middle-x mb-3`;\n  notificationEl.classList.remove(\"d-none\");\n\n  // Ẩn thông báo sau 3 giây\n  // eslint-disable-next-line no-undef\n  setTimeout(() => {\n    notificationEl.classList.add(\"d-none\");\n  }, 3000);\n}\n"],"names":["mapData","SheetNameSource","TableNameSource","KeyColumnNameSource","ListColumnNameSource","SheetNameTarget","TableNameTarget","KeyColumnNameTarget","ListColumnNameTarget","Excel","run","context","sourceTable","workbook","worksheets","getItem","tables","targetTable","sourceRange","getDataBodyRange","targetRange","load","sourceHeaderRange","getHeaderRowRange","targetHeaderRange","sync","then","sourceData","values","targetData","targetKeys","Set","map","row","headersSource","headersTarget","keyColIndexSource","indexOf","listColIndexesSource","col","listColIndexesTarget","newRows","forEach","keyValue","has","newRow","Array","length","fill","sourceIndex","index","targetIndex","push","rows","add","console","log","catch","error","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Office","onReady","info","host","HostType","lcNameS","lcNameT","document","getElementById","onclick"],"sourceRoot":""}